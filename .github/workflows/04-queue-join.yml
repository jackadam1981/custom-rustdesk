name: 04 - Queue Join

on:
  workflow_call:
    inputs:
      trigger_output:
        description: "Trigger workflow output data"
        required: true
        type: string
      trigger_type:
        description: "Trigger type (issue or workflow_dispatch)"
        required: true
        type: string
      build_id:
        description: "Build ID"
        required: true
        type: string
    outputs:
      join_success:
        description: "Whether join was successful"
        value: ${{ jobs.queue_join.outputs.join_success }}
      queue_position:
        description: "Position in queue"
        value: ${{ jobs.queue_join.outputs.queue_position }}

jobs:
  queue_join:
    runs-on: ubuntu-latest
    outputs:
      join_success: ${{ steps.join.outputs.join_success }}
      queue_position: ${{ steps.join.outputs.queue_position }}
    steps:
      - name: Setup data
        id: setup
        run: |
          # ä½¿ç”¨è¾“å…¥å‚æ•°
          TRIGGER_OUTPUT='${{ inputs.trigger_output }}'
          TRIGGER_TYPE='${{ inputs.trigger_type }}'
          BUILD_ID='${{ inputs.build_id }}'
          
          if [ -z "$TRIGGER_OUTPUT" ]; then
            echo "âŒ No trigger output provided"
            exit 1
          fi
          
          echo "TRIGGER_OUTPUT=$TRIGGER_OUTPUT" >> $GITHUB_ENV
          echo "TRIGGER_TYPE=$TRIGGER_TYPE" >> $GITHUB_ENV
          echo "BUILD_ID=$BUILD_ID" >> $GITHUB_ENV
          
          # èŽ·å–è§¦å‘æ–¹å¼
          if [ "$TRIGGER_TYPE" = "workflow_dispatch" ]; then
            echo "QUEUE_LIMIT=5" >> $GITHUB_ENV
          else
            echo "QUEUE_LIMIT=3" >> $GITHUB_ENV
          fi
      
      - name: Extract data
        id: extract
        run: |
          # ä»Žtriggeré˜¶æ®µèŽ·å–æ•°æ®
          INPUT='${{ env.TRIGGER_OUTPUT }}'
          
          # éªŒè¯è¾“å…¥JSONæ ¼å¼
          echo "Validating input JSON format..."
          echo "$INPUT" | jq . > /dev/null
          echo "Input JSON validation passed"
          
          # è®¾ç½®çŽ¯å¢ƒå˜é‡ä¾›åŽç»­æ­¥éª¤ä½¿ç”¨
          echo "CURRENT_DATA=$INPUT" >> $GITHUB_ENV

      - name: Auto cleanup queue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          # è‡ªåŠ¨æ¸…ç†é˜Ÿåˆ—ï¼Œå¤„ç†å¼‚å¸¸é”å’Œå¡ä½çš„çŠ¶æ€
          echo "Starting automatic queue cleanup..."
          
          # åŠ è½½å…±äº«å·¥å…·å‡½æ•°
          source .github/workflows/shared/github-utils.sh
          
          # é‡è¯•æœºåˆ¶å‚æ•°
          MAX_RETRIES=5
          RETRY_DELAY=10
          
          # é‡è¯•æ¸…ç†é˜Ÿåˆ—
          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $attempt of $MAX_RETRIES to cleanup queue..."
            
            QUEUE_MANAGER_ISSUE="1"
            QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
            QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
            
            # å¦‚æžœè§£æžJSONå¤±è´¥ï¼Œç›´æŽ¥é‡ç½®
            if [ -z "$QUEUE_DATA" ] || ! echo "$QUEUE_DATA" | jq . > /dev/null 2>&1; then
              echo "âŒ JSON parsing failed, resetting queue template"
              reset_queue_to_default "$QUEUE_MANAGER_ISSUE" "JSONè§£æžå¤±è´¥ï¼Œé‡ç½®ä¸ºé»˜è®¤æ¨¡æ¿"
              echo "âœ… Queue reset triggered"
              break
            fi
            
            # èŽ·å–å½“å‰çŠ¶æ€
            CURRENT_VERSION=$(echo "$QUEUE_DATA" | jq -r '.version // 1')
            LOCK_RUN_ID=$(echo "$QUEUE_DATA" | jq -r '.run_id // null')
            QUEUE=$(echo "$QUEUE_DATA" | jq -r '.queue // []')
            
            echo "Current version: $CURRENT_VERSION"
            echo "Lock run_id: $LOCK_RUN_ID"
            echo "Queue: $QUEUE"
            
            # æ£€æŸ¥éœ€è¦æ¸…ç†çš„é¡¹ç›®
            NEED_CLEANUP=false
            CLEANUP_REASONS=()
            
            # 1. æ£€æŸ¥é”è¶…æ—¶ï¼ˆè¶…è¿‡2å°æ—¶ï¼‰
            if [ "$LOCK_RUN_ID" != "null" ]; then
              LOCK_ISSUE_JOIN_TIME=$(echo "$QUEUE" | \
                jq -r --arg run_id "$LOCK_RUN_ID" \
                '.[] | select(.issue_number == $run_id) | .join_time // empty' 2>/dev/null || echo "")
              
              if [ -n "$LOCK_ISSUE_JOIN_TIME" ]; then
                JOIN_TIMESTAMP=$(date -d "$LOCK_ISSUE_JOIN_TIME" +%s 2>/dev/null || echo "0")
                CURRENT_TIMESTAMP=$(date +%s)
                LOCK_DURATION_HOURS=$(( (CURRENT_TIMESTAMP - JOIN_TIMESTAMP) / 3600 ))
                
                if [ "$LOCK_DURATION_HOURS" -ge 2 ]; then
                  NEED_CLEANUP=true
                  CLEANUP_REASONS+=("é”è¶…æ—¶ï¼šå·²å ç”¨${LOCK_DURATION_HOURS}å°æ—¶")
                  echo "âŒ Lock timeout: ${LOCK_DURATION_HOURS} hours"
                fi
              else
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("é”å¼‚å¸¸ï¼šæ‰¾ä¸åˆ°é”æŒæœ‰æ—¶é—´")
                echo "âŒ Lock anomaly: no join time found"
              fi
            fi
            
            # 2. æ£€æŸ¥é‡å¤é¡¹
            if [ "$(echo "$QUEUE" | jq -r 'type')" = "array" ]; then
              DUPLICATE_ITEMS=$(echo "$QUEUE" | \
                jq -r 'group_by(.issue_number) | .[] | select(length > 1) | .[0].issue_number' 2>/dev/null || echo "")
              
              if [ -n "$DUPLICATE_ITEMS" ]; then
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("é˜Ÿåˆ—é‡å¤ï¼šæž„å»ºé¡¹ç›® $DUPLICATE_ITEMS é‡å¤")
                echo "âŒ Duplicate items: $DUPLICATE_ITEMS"
              fi
            fi
            
            # 3. æ£€æŸ¥æ— æ•ˆissue
            if [ "$(echo "$QUEUE" | jq -r 'type')" = "array" ]; then
              INVALID_ISSUES=()
              for issue_number in $(echo "$QUEUE" | jq -r '.[].issue_number'); do
                ISSUE_RESPONSE=$(curl -s \
                  -H "Authorization: token $GITHUB_TOKEN" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/$GITHUB_REPOSITORY/issues/$issue_number")
                
                if echo "$ISSUE_RESPONSE" | jq -e '.message' | grep -q "Not Found"; then
                  INVALID_ISSUES+=("$issue_number")
                  echo "âŒ Issue #$issue_number not found"
                fi
              done
              
              if [ ${#INVALID_ISSUES[@]} -gt 0 ]; then
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("æ— æ•ˆissueï¼š${INVALID_ISSUES[*]} ä¸å­˜åœ¨")
                echo "âŒ Invalid issues: ${INVALID_ISSUES[*]}"
              fi
            fi
            
            # 4. æ£€æŸ¥å·²ç»“æŸçš„runs
            if [ "$(echo "$QUEUE" | jq -r 'type')" = "array" ]; then
              EXPIRED_RUNS=()
              for run_id in $(echo "$QUEUE" | jq -r '.[] | select(.trigger_type == "workflow_dispatch") | .issue_number'); do
                # æ£€æŸ¥workflow runæ˜¯å¦å­˜åœ¨ä¸”æœªå®Œæˆ
                RUN_RESPONSE=$(curl -s \
                  -H "Authorization: token $GITHUB_TOKEN" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/$GITHUB_REPOSITORY/actions/runs/$run_id")
                
                if echo "$RUN_RESPONSE" | jq -e '.message' | grep -q "Not Found"; then
                  EXPIRED_RUNS+=("$run_id")
                  echo "âŒ Run #$run_id not found"
                else
                  # æ£€æŸ¥runçŠ¶æ€ï¼šcompleted, cancelled, failure, skipped éƒ½æ˜¯å·²ç»“æŸçŠ¶æ€
                  RUN_STATUS=$(echo "$RUN_RESPONSE" | jq -r '.status // "unknown"')
                  RUN_CONCLUSION=$(echo "$RUN_RESPONSE" | jq -r '.conclusion // "unknown"')
                  
                  if [ "$RUN_STATUS" = "completed" ] || [ "$RUN_STATUS" = "cancelled" ] || [ "$RUN_STATUS" = "failure" ] || [ "$RUN_STATUS" = "skipped" ]; then
                    EXPIRED_RUNS+=("$run_id")
                    echo "âŒ Run #$run_id ended with status: $RUN_STATUS, conclusion: $RUN_CONCLUSION"
                  fi
                fi
              done
              
              if [ ${#EXPIRED_RUNS[@]} -gt 0 ]; then
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("å·²ç»“æŸrunsï¼š${EXPIRED_RUNS[*]} å·²å®Œæˆ/å–æ¶ˆ/å¤±è´¥/è·³è¿‡æˆ–ä¸å­˜åœ¨")
                echo "âŒ Expired runs: ${EXPIRED_RUNS[*]}"
              fi
            fi
            
            # æ‰§è¡Œæ¸…ç†
            if [ "$NEED_CLEANUP" = true ]; then
              echo "Performing queue cleanup..."
              echo "Cleanup reasons: ${CLEANUP_REASONS[*]}"
              
              # æž„å»ºæ¸…ç†åŽŸå› æ–‡æœ¬
              CLEANUP_REASON_TEXT=""
              for reason in "${CLEANUP_REASONS[@]}"; do
                CLEANUP_REASON_TEXT="${CLEANUP_REASON_TEXT}â€¢ $reason\n"
              done
              
              # ä½¿ç”¨å·¥å…·å‡½æ•°æ¸…ç†é˜Ÿåˆ—æ•°æ®
              if cleanup_queue_data "$QUEUE_MANAGER_ISSUE" "$CLEANUP_REASON_TEXT" "$CURRENT_VERSION" "$QUEUE_DATA" "${INVALID_ISSUES[@]}" "${EXPIRED_RUNS[@]}"; then
                echo "âœ… Queue cleanup successful on attempt $attempt"
                break
              else
                echo "âŒ Queue cleanup failed on attempt $attempt"
                if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                  echo "Retrying in $RETRY_DELAY seconds..."
                  sleep $RETRY_DELAY
                else
                  echo "Max retries reached, triggering queue reset..."
                  reset_queue_to_default "$QUEUE_MANAGER_ISSUE" "æ¸…ç†å¤±è´¥ï¼Œé‡ç½®é˜Ÿåˆ—"
                  break
                fi
              fi
            else
              echo "No cleanup needed, queue is healthy"
              break
            fi
          done

      - name: Join queue
        id: join
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          # åŠ è½½å…±äº«å·¥å…·å‡½æ•°
          source .github/workflows/shared/github-utils.sh
          
          echo "Joining build queue..."
          
          # èŽ·å–å½“å‰é˜Ÿåˆ—çŠ¶æ€
          QUEUE_MANAGER_ISSUE="1"
          QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
          QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
          
          # å¦‚æžœè§£æžJSONå¤±è´¥ï¼Œç›´æŽ¥é‡ç½®
          if [ -z "$QUEUE_DATA" ] || ! echo "$QUEUE_DATA" | jq . > /dev/null 2>&1; then
            echo "âŒ JSON parsing failed, resetting queue template"
            reset_queue_to_default "$QUEUE_MANAGER_ISSUE" "JSONè§£æžå¤±è´¥ï¼Œé‡ç½®ä¸ºé»˜è®¤æ¨¡æ¿"
            QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
            QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
          fi
          
          # èŽ·å–å½“å‰çŠ¶æ€
          CURRENT_VERSION=$(echo "$QUEUE_DATA" | jq -r '.version // 1')
          LOCK_RUN_ID=$(echo "$QUEUE_DATA" | jq -r '.run_id // null')
          QUEUE=$(echo "$QUEUE_DATA" | jq -r '.queue // []')
          
          echo "Current version: $CURRENT_VERSION"
          echo "Lock run_id: $LOCK_RUN_ID"
          echo "Queue: $QUEUE"
          
          # æ£€æŸ¥é˜Ÿåˆ—é•¿åº¦é™åˆ¶
          QUEUE_LENGTH=$(echo "$QUEUE" | jq 'length')
          QUEUE_LIMIT="${{ env.QUEUE_LIMIT }}"
          
          echo "Queue length: $QUEUE_LENGTH, Limit: $QUEUE_LIMIT"
          
          if [ "$QUEUE_LENGTH" -ge "$QUEUE_LIMIT" ]; then
            echo "âŒ Queue is full (limit: $QUEUE_LIMIT)"
            
            # æ·»åŠ æ‹’ç»è¯„è®º
            REJECT_COMMENT="## âŒ æž„å»ºè¢«æ‹’ç»

            **æ‹’ç»åŽŸå› ï¼š** æž„å»ºé˜Ÿåˆ—å·²æ»¡ï¼ˆå½“å‰ $QUEUE_LENGTH/$QUEUE_LIMITï¼‰
            
            **å½“å‰é˜Ÿåˆ—ï¼š**
            $(echo "$QUEUE" | jq -r '.[] | "â€¢ #\(.issue_number) - \(.customer) (\(.join_time))"')
            
            **å»ºè®®ï¼š** è¯·ç¨åŽé‡è¯•æˆ–è”ç³»ç®¡ç†å‘˜
            **æ—¶é—´ï¼š** $(date '+%Y-%m-%d %H:%M:%S')"
            
            # èŽ·å–åŽŸå§‹issueç¼–å·
            ORIGINAL_ISSUE_NUMBER="${{ env.BUILD_ID }}"
            
            if [ -n "$ORIGINAL_ISSUE_NUMBER" ]; then
              add_issue_comment "$ORIGINAL_ISSUE_NUMBER" "$REJECT_COMMENT"
            fi
            
            echo "join_success=false" >> $GITHUB_OUTPUT
            echo "queue_position=-1" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨é˜Ÿåˆ—ä¸­
          EXISTING_ITEM=$(echo "$QUEUE" | jq -r --arg build_id "${{ env.BUILD_ID }}" '.[] | select(.build_id == $build_id) | .issue_number // empty')
          
          if [ -n "$EXISTING_ITEM" ]; then
            echo "âš ï¸ Already in queue at position: $EXISTING_ITEM"
            
            # è®¡ç®—é˜Ÿåˆ—ä½ç½®
            QUEUE_POSITION=$(echo "$QUEUE" | jq -r --arg build_id "${{ env.BUILD_ID }}" 'index(.[] | select(.build_id == $build_id)) + 1')
            
            echo "join_success=true" >> $GITHUB_OUTPUT
            echo "queue_position=$QUEUE_POSITION" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # å‡†å¤‡æ–°é˜Ÿåˆ—é¡¹æ•°æ®
          CURRENT_TIME=$(date '+%Y-%m-%d %H:%M:%S')
          BUILD_TITLE="Custom Rustdesk Build"
          
          # ä»Žtriggeræ•°æ®ä¸­æå–ä¿¡æ¯
          TRIGGER_DATA='${{ env.CURRENT_DATA }}'
          TAG=$(echo "$TRIGGER_DATA" | jq -r '.tag')
          CUSTOMER=$(echo "$TRIGGER_DATA" | jq -r '.customer')
          CUSTOMER_LINK=$(echo "$TRIGGER_DATA" | jq -r '.customer_link')
          SLOGAN=$(echo "$TRIGGER_DATA" | jq -r '.slogan')
          
          # åŠ å¯†æ•æ„Ÿå‚æ•°
          ENCRYPTION_KEY="${{ vars.ENCRYPTION_KEY }}"
          
          if [ -z "$ENCRYPTION_KEY" ]; then
            echo "âŒ Encryption key not found in repository variables"
            echo "join_success=false" >> $GITHUB_OUTPUT
            echo "queue_position=-1" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # åŠ å¯†æ•æ„Ÿå‚æ•°
          ENCRYPTED_EMAIL=$(encrypt_params "$(echo "$TRIGGER_DATA" | jq -r '.email')")
          ENCRYPTED_SUPER_PASSWORD=$(encrypt_params "$(echo "$TRIGGER_DATA" | jq -r '.super_password')")
          ENCRYPTED_RENDEZVOUS_SERVER=$(encrypt_params "$(echo "$TRIGGER_DATA" | jq -r '.rendezvous_server')")
          ENCRYPTED_RS_PUB_KEY=$(encrypt_params "$(echo "$TRIGGER_DATA" | jq -r '.rs_pub_key')")
          ENCRYPTED_API_SERVER=$(encrypt_params "$(echo "$TRIGGER_DATA" | jq -r '.api_server')")
          
          # åˆ›å»ºæ–°çš„é˜Ÿåˆ—é¡¹
          NEW_QUEUE_ITEM=$(jq -c -n \
            --arg build_id "${{ env.BUILD_ID }}" \
            --arg build_title "$BUILD_TITLE" \
            --arg trigger_type "${{ env.TRIGGER_TYPE }}" \
            --arg tag "$TAG" \
            --arg customer "$CUSTOMER" \
            --arg customer_link "$CUSTOMER_LINK" \
            --arg slogan "$SLOGAN" \
            --arg join_time "$CURRENT_TIME" \
            --arg encrypted_email "$ENCRYPTED_EMAIL" \
            --arg encrypted_super_password "$ENCRYPTED_SUPER_PASSWORD" \
            --arg encrypted_rendezvous_server "$ENCRYPTED_RENDEZVOUS_SERVER" \
            --arg encrypted_rs_pub_key "$ENCRYPTED_RS_PUB_KEY" \
            --arg encrypted_api_server "$ENCRYPTED_API_SERVER" \
            '{build_id: $build_id, build_title: $build_title, trigger_type: $trigger_type, tag: $tag, customer: $customer, customer_link: $customer_link, slogan: $slogan, join_time: $join_time, encrypted_email: $encrypted_email, encrypted_super_password: $encrypted_super_password, encrypted_rendezvous_server: $encrypted_rendezvous_server, encrypted_rs_pub_key: $encrypted_rs_pub_key, encrypted_api_server: $encrypted_api_server}')
          
          # æ·»åŠ åˆ°é˜Ÿåˆ—
          NEW_QUEUE=$(echo "$QUEUE" | jq --argjson new_item "$NEW_QUEUE_ITEM" '. + [$new_item]')
          
          # æ›´æ–°é˜Ÿåˆ—æ•°æ®
          NEW_QUEUE_DATA=$(echo "$QUEUE_DATA" | jq --argjson new_queue "$NEW_QUEUE" '.queue = $new_queue')
          
          # æ›´æ–°é˜Ÿåˆ—ç®¡ç†issue
          UPDATED_TOTAL_COUNT=$(echo "$NEW_QUEUE_DATA" | jq '.queue | length // 0')
          UPDATED_ISSUE_COUNT=$(echo "$NEW_QUEUE_DATA" | jq '.queue | map(select(.trigger_type == "issue")) | length // 0')
          UPDATED_WORKFLOW_COUNT=$(echo "$NEW_QUEUE_DATA" | jq '.queue | map(select(.trigger_type == "workflow_dispatch")) | length // 0')
          
          UPDATED_BODY="## æž„å»ºé˜Ÿåˆ—ç®¡ç†\n\n**æœ€åŽæ›´æ–°æ—¶é—´ï¼š** \$(date '+%Y-%m-%d %H:%M:%S')\n\n### å½“å‰çŠ¶æ€\n- **æž„å»ºé”çŠ¶æ€ï¼š** ç©ºé—² ðŸ”“\n- **å½“å‰æž„å»ºï¼š** æ— \n- **é”æŒæœ‰è€…ï¼š** æ— \n- **ç‰ˆæœ¬ï¼š** $CURRENT_VERSION\n\n### æž„å»ºé˜Ÿåˆ—\n- **å½“å‰æ•°é‡ï¼š** $UPDATED_TOTAL_COUNT/5\n- **Issueè§¦å‘ï¼š** $UPDATED_ISSUE_COUNT/3\n- **æ‰‹åŠ¨è§¦å‘ï¼š** $UPDATED_WORKFLOW_COUNT/5\n\n---\n\n### é˜Ÿåˆ—æ•°æ®\n\`\`\`json\n$NEW_QUEUE_DATA\n\`\`\`"
          
                    if update_queue_issue "$QUEUE_MANAGER_ISSUE" "$UPDATED_BODY"; then
            echo "âœ… Successfully joined queue"
            
            # è®¡ç®—é˜Ÿåˆ—ä½ç½®
            QUEUE_POSITION=$(echo "$NEW_QUEUE" | jq 'length')
            
            # æ·»åŠ æˆåŠŸè¯„è®º
            SUCCESS_COMMENT="## âœ… æž„å»ºå·²åŠ å…¥é˜Ÿåˆ—

            **é˜Ÿåˆ—ä½ç½®ï¼š** $QUEUE_POSITION/$QUEUE_LIMIT
            **æž„å»ºIDï¼š** ${{ env.BUILD_ID }}
            **æ ‡ç­¾ï¼š** $TAG
            **å®¢æˆ·ï¼š** $CUSTOMER
            **æ ‡è¯­ï¼š** $SLOGAN
            **åŠ å…¥æ—¶é—´ï¼š** $CURRENT_TIME
            
            **çŠ¶æ€ï¼š** ç­‰å¾…æž„å»ºä¸­ â³
            **é¢„è®¡ç­‰å¾…æ—¶é—´ï¼š** çº¦ $((QUEUE_POSITION * 30)) åˆ†é’Ÿ"
            
            # èŽ·å–åŽŸå§‹issueç¼–å·
            ORIGINAL_ISSUE_NUMBER="${{ env.BUILD_ID }}"
            
            if [ -n "$ORIGINAL_ISSUE_NUMBER" ]; then
              add_issue_comment "$ORIGINAL_ISSUE_NUMBER" "$SUCCESS_COMMENT"
            fi
            
            echo "join_success=true" >> $GITHUB_OUTPUT
            echo "queue_position=$QUEUE_POSITION" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to join queue"
            echo "join_success=false" >> $GITHUB_OUTPUT
            echo "queue_position=-1" >> $GITHUB_OUTPUT
            exit 1
          fi 