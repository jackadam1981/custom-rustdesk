name: 03 - Queue Join and Wait

on:
  workflow_call:
    inputs:
      trigger_output:
        description: "Trigger workflow output data"
        required: true
        type: string
      trigger_type:
        description: "Trigger type (issue or workflow_dispatch)"
        required: true
        type: string
      build_id:
        description: "Build ID"
        required: true
        type: string
    outputs:
      join_success:
        description: "Whether join was successful"
        value: ${{ jobs.queue_join.outputs.join_success }}
      queue_position:
        description: "Position in queue"
        value: ${{ jobs.queue_join.outputs.queue_position }}

jobs:
  queue_join:
    runs-on: ubuntu-latest
    outputs:
      join_success: ${{ steps.join.outputs.join_success }}
      queue_position: ${{ steps.join.outputs.queue_position }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup data
        id: setup
        run: |
          # ä½¿ç”¨è¾“å…¥å‚æ•°
          TRIGGER_OUTPUT='${{ inputs.trigger_output }}'
          TRIGGER_TYPE='${{ inputs.trigger_type }}'
          BUILD_ID='${{ inputs.build_id }}'
          
          if [ -z "$TRIGGER_OUTPUT" ]; then
            echo "âŒ No trigger output provided"
            exit 1
          fi
          
          echo "TRIGGER_OUTPUT=$TRIGGER_OUTPUT" >> $GITHUB_ENV
          echo "TRIGGER_TYPE=$TRIGGER_TYPE" >> $GITHUB_ENV
          echo "BUILD_ID=$BUILD_ID" >> $GITHUB_ENV
          
          # èŽ·å–è§¦å‘æ–¹å¼
          if [ "$TRIGGER_TYPE" = "workflow_dispatch" ]; then
            echo "QUEUE_LIMIT=5" >> $GITHUB_ENV
          else
            echo "QUEUE_LIMIT=3" >> $GITHUB_ENV
          fi
      
      - name: Extract data
        id: extract
        run: |
          # ä»Žtriggeré˜¶æ®µèŽ·å–æ•°æ®
          INPUT='${{ env.TRIGGER_OUTPUT }}'
          
          # éªŒè¯è¾“å…¥JSONæ ¼å¼
          echo "Validating input JSON format..."
          echo "$INPUT" | jq . > /dev/null
          echo "Input JSON validation passed"
          
          # è®¾ç½®çŽ¯å¢ƒå˜é‡ä¾›åŽç»­æ­¥éª¤ä½¿ç”¨
          echo "CURRENT_DATA=$INPUT" >> $GITHUB_ENV
          
      - name: Join queue with auto cleanup and wait
        id: join
        env:
          GITHUB_TOKEN: ${{ secrets.ISSUE_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}
        run: |
          # åŠ è½½å…±äº«å·¥å…·å‡½æ•°
          source .github/workflows/shared/github-utils.sh
          
          echo "Starting queue join process with auto cleanup..."
          
          # é‡è¯•æœºåˆ¶å‚æ•°
          MAX_RETRIES=5
          RETRY_DELAY=10
          
          # é‡è¯•åŠ å…¥é˜Ÿåˆ—
          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $attempt of $MAX_RETRIES to join queue..."
            
            QUEUE_MANAGER_ISSUE="1"
            QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
            echo "DEBUG: Raw queue manager content length: $(echo "$QUEUE_MANAGER_CONTENT" | wc -c)"
            QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
            echo "DEBUG: Extracted queue data: '$QUEUE_DATA'"
            
            # å¦‚æžœè§£æžJSONå¤±è´¥ï¼Œç›´æŽ¥é‡ç½®
            if [ -z "$QUEUE_DATA" ] || ! echo "$QUEUE_DATA" | jq . > /dev/null 2>&1; then
              echo "âŒ JSON parsing failed, resetting queue template"
              echo "DEBUG: Failed queue data: '$QUEUE_DATA'"
              reset_queue_to_default "$QUEUE_MANAGER_ISSUE" "JSONè§£æžå¤±è´¥ï¼Œé‡ç½®ä¸ºé»˜è®¤æ¨¡æ¿"
              QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
              QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
              echo "DEBUG: After reset, queue data: '$QUEUE_DATA'"
            fi
            
            # èŽ·å–å½“å‰çŠ¶æ€
            CURRENT_VERSION=$(echo "$QUEUE_DATA" | jq -r '.version // 1')
            LOCK_RUN_ID=$(echo "$QUEUE_DATA" | jq -r '.run_id // null')
            QUEUE=$(echo "$QUEUE_DATA" | jq -r '.queue // []')
            
            echo "Current version: $CURRENT_VERSION"
            echo "Lock run_id: $LOCK_RUN_ID"
            echo "Queue: $QUEUE"
            
            # === è‡ªåŠ¨æ¸…ç†é€»è¾‘ ===
            NEED_CLEANUP=false
            CLEANUP_REASONS=()
            
            # 1. æ£€æŸ¥é”è¶…æ—¶ï¼ˆè¶…è¿‡2å°æ—¶ï¼‰
            if [ "$LOCK_RUN_ID" != "null" ]; then
              LOCK_ISSUE_JOIN_TIME=$(echo "$QUEUE" | \
                jq -r --arg run_id "$LOCK_RUN_ID" \
                '.[] | select(.issue_number == $run_id) | .join_time // empty' 2>/dev/null || echo "")
              
              if [ -n "$LOCK_ISSUE_JOIN_TIME" ]; then
                JOIN_TIMESTAMP=$(date -d "$LOCK_ISSUE_JOIN_TIME" +%s 2>/dev/null || echo "0")
                CURRENT_TIMESTAMP=$(date +%s)
                LOCK_DURATION_HOURS=$(( (CURRENT_TIMESTAMP - JOIN_TIMESTAMP) / 3600 ))
                
                if [ "$LOCK_DURATION_HOURS" -ge 2 ]; then
                  NEED_CLEANUP=true
                  CLEANUP_REASONS+=("é”è¶…æ—¶ï¼šå·²å ç”¨${LOCK_DURATION_HOURS}å°æ—¶")
                  echo "âŒ Lock timeout: ${LOCK_DURATION_HOURS} hours"
                fi
              else
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("é”å¼‚å¸¸ï¼šæ‰¾ä¸åˆ°é”æŒæœ‰æ—¶é—´")
                echo "âŒ Lock anomaly: no join time found"
              fi
            fi
            
            # 2. æ£€æŸ¥é‡å¤é¡¹
            if [ "$(echo "$QUEUE" | jq -r 'type')" = "array" ]; then
              DUPLICATE_ITEMS=$(echo "$QUEUE" | \
                jq -r 'group_by(.issue_number) | .[] | select(length > 1) | .[0].issue_number' 2>/dev/null || echo "")
              
              if [ -n "$DUPLICATE_ITEMS" ]; then
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("é˜Ÿåˆ—é‡å¤ï¼šæž„å»ºé¡¹ç›® $DUPLICATE_ITEMS é‡å¤")
                echo "âŒ Duplicate items: $DUPLICATE_ITEMS"
              fi
            fi
            
            # 3. æ£€æŸ¥æ— æ•ˆissue
            if [ "$(echo "$QUEUE" | jq -r 'type')" = "array" ]; then
              INVALID_ISSUES=()
              for issue_number in $(echo "$QUEUE" | jq -r '.[].issue_number'); do
                ISSUE_RESPONSE=$(curl -s \
                  -H "Authorization: token $GITHUB_TOKEN" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/$GITHUB_REPOSITORY/issues/$issue_number")
                
                if echo "$ISSUE_RESPONSE" | jq -e '.message' | grep -q "Not Found"; then
                  INVALID_ISSUES+=("$issue_number")
                  echo "âŒ Issue #$issue_number not found"
                fi
              done
              
              if [ ${#INVALID_ISSUES[@]} -gt 0 ]; then
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("æ— æ•ˆissueï¼š${INVALID_ISSUES[*]} ä¸å­˜åœ¨")
                echo "âŒ Invalid issues: ${INVALID_ISSUES[*]}"
              fi
            fi
            
            # 4. æ£€æŸ¥å·²ç»“æŸçš„runs
            if [ "$(echo "$QUEUE" | jq -r 'type')" = "array" ]; then
              EXPIRED_RUNS=()
              for run_id in $(echo "$QUEUE" | jq -r '.[] | select(.trigger_type == "workflow_dispatch") | .issue_number'); do
                # æ£€æŸ¥workflow runæ˜¯å¦å­˜åœ¨ä¸”æœªå®Œæˆ
                RUN_RESPONSE=$(curl -s \
                  -H "Authorization: token $GITHUB_TOKEN" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/$GITHUB_REPOSITORY/actions/runs/$run_id")
                
                if echo "$RUN_RESPONSE" | jq -e '.message' | grep -q "Not Found"; then
                  EXPIRED_RUNS+=("$run_id")
                  echo "âŒ Run #$run_id not found"
                else
                  # æ£€æŸ¥runçŠ¶æ€ï¼šcompleted, cancelled, failure, skipped éƒ½æ˜¯å·²ç»“æŸçŠ¶æ€
                  RUN_STATUS=$(echo "$RUN_RESPONSE" | jq -r '.status // "unknown"')
                  RUN_CONCLUSION=$(echo "$RUN_RESPONSE" | jq -r '.conclusion // "unknown"')
                  
                  if [ "$RUN_STATUS" = "completed" ] || [ "$RUN_STATUS" = "cancelled" ] || [ "$RUN_STATUS" = "failure" ] || [ "$RUN_STATUS" = "skipped" ]; then
                    EXPIRED_RUNS+=("$run_id")
                    echo "âŒ Run #$run_id ended with status: $RUN_STATUS, conclusion: $RUN_CONCLUSION"
                  fi
                fi
              done
              
              if [ ${#EXPIRED_RUNS[@]} -gt 0 ]; then
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("å·²ç»“æŸrunsï¼š${EXPIRED_RUNS[*]} å·²å®Œæˆ/å–æ¶ˆ/å¤±è´¥/è·³è¿‡æˆ–ä¸å­˜åœ¨")
                echo "âŒ Expired runs: ${EXPIRED_RUNS[*]}"
              fi
            fi
            
            # æ‰§è¡Œæ¸…ç†
            if [ "$NEED_CLEANUP" = true ]; then
              echo "Performing queue cleanup..."
              echo "Cleanup reasons: ${CLEANUP_REASONS[*]}"
              
              # æž„å»ºæ¸…ç†åŽŸå› æ–‡æœ¬
              CLEANUP_REASON_TEXT=""
              for reason in "${CLEANUP_REASONS[@]}"; do
                CLEANUP_REASON_TEXT="${CLEANUP_REASON_TEXT}- $reason
              "
              done
              
              # ä½¿ç”¨å·¥å…·å‡½æ•°æ¸…ç†é˜Ÿåˆ—æ•°æ®
              if cleanup_queue_data "$QUEUE_MANAGER_ISSUE" "$CLEANUP_REASON_TEXT" "$CURRENT_VERSION" "$QUEUE_DATA" "${INVALID_ISSUES[@]}" "${EXPIRED_RUNS[@]}"; then
                echo "âœ… Queue cleanup successful on attempt $attempt"
                # é‡æ–°èŽ·å–æ¸…ç†åŽçš„é˜Ÿåˆ—æ•°æ®
                QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
                QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
                QUEUE=$(echo "$QUEUE_DATA" | jq -r '.queue // []')
                
                # è°ƒè¯•ï¼šè¾“å‡ºæ¸…ç†åŽçš„æ•°æ®
                echo "After cleanup - QUEUE_DATA: $QUEUE_DATA"
                echo "After cleanup - QUEUE: $QUEUE"
              else
                echo "âŒ Queue cleanup failed on attempt $attempt"
                if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                  echo "Retrying in $RETRY_DELAY seconds..."
                  sleep $RETRY_DELAY
                  continue
                else
                  echo "Max retries reached, triggering queue reset..."
                  reset_queue_to_default "$QUEUE_MANAGER_ISSUE" "æ¸…ç†å¤±è´¥ï¼Œé‡ç½®é˜Ÿåˆ—"
                  QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
                  QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
                  QUEUE=$(echo "$QUEUE_DATA" | jq -r '.queue // []')
                  
                  # è°ƒè¯•ï¼šè¾“å‡ºé‡ç½®åŽçš„æ•°æ®
                  echo "After reset - QUEUE_DATA: $QUEUE_DATA"
                  echo "After reset - QUEUE: $QUEUE"
                fi
              fi
            else
              echo "No cleanup needed, queue is healthy"
            fi
            
            # === åŠ å…¥é˜Ÿåˆ—é€»è¾‘ ===
            echo "Joining build queue..."
            
            # æ£€æŸ¥é˜Ÿåˆ—é•¿åº¦é™åˆ¶
            QUEUE_LENGTH=$(echo "$QUEUE" | jq 'length // 0')
            QUEUE_LIMIT="${{ env.QUEUE_LIMIT }}"
            
            echo "Queue length: $QUEUE_LENGTH, Limit: $QUEUE_LIMIT"
            
            # ç¡®ä¿QUEUE_LENGTHæ˜¯æ•°å­—
            if [ -z "$QUEUE_LENGTH" ] || ! [[ "$QUEUE_LENGTH" =~ ^[0-9]+$ ]]; then
              QUEUE_LENGTH=0
              echo "Fixed queue length to: $QUEUE_LENGTH"
            fi
            
            if [ "$QUEUE_LENGTH" -ge "$QUEUE_LIMIT" ]; then
              echo "âŒ Queue is full (limit: $QUEUE_LIMIT)"
              
              # æ·»åŠ æ‹’ç»è¯„è®º
              REJECT_COMMENT="## âŒ æž„å»ºè¢«æ‹’ç»

              **æ‹’ç»åŽŸå› ï¼š** æž„å»ºé˜Ÿåˆ—å·²æ»¡ï¼ˆå½“å‰ $QUEUE_LENGTH/$QUEUE_LIMITï¼‰
              
              **å½“å‰é˜Ÿåˆ—ï¼š**
              $(echo "$QUEUE" | jq -r '.[] | "â€¢ #\(.issue_number) - \(.customer) (\(.join_time))"')
              
              **å»ºè®®ï¼š** è¯·ç¨åŽé‡è¯•æˆ–è”ç³»ç®¡ç†å‘˜
              **æ—¶é—´ï¼š** $(date '+%Y-%m-%d %H:%M:%S')"
              
              # èŽ·å–åŽŸå§‹issueç¼–å·
              ORIGINAL_ISSUE_NUMBER="${{ env.BUILD_ID }}"
              
              if [ -n "$ORIGINAL_ISSUE_NUMBER" ]; then
                add_issue_comment_if_issue_trigger "${{ env.TRIGGER_TYPE }}" "${{ env.BUILD_ID }}" "$REJECT_COMMENT"
              fi
              
              echo "join_success=false" >> $GITHUB_OUTPUT
              echo "queue_position=-1" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨é˜Ÿåˆ—ä¸­
            EXISTING_ITEM=$(echo "$QUEUE" | jq -r --arg build_id "${{ env.BUILD_ID }}" '.[] | select(.build_id == $build_id) | .issue_number // empty')
            
            if [ -n "$EXISTING_ITEM" ]; then
              echo "âš ï¸ Already in queue at position: $EXISTING_ITEM"
              
              # è®¡ç®—é˜Ÿåˆ—ä½ç½®
              QUEUE_POSITION=$(echo "$QUEUE" | jq -r --arg build_id "${{ env.BUILD_ID }}" 'index(.[] | select(.build_id == $build_id)) + 1')
              
              echo "join_success=true" >> $GITHUB_OUTPUT
              echo "queue_position=$QUEUE_POSITION" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # å‡†å¤‡æ–°é˜Ÿåˆ—é¡¹æ•°æ®
            CURRENT_TIME=$(date '+%Y-%m-%d %H:%M:%S')
            BUILD_TITLE="Custom Rustdesk Build"
            
            # ä»Žtriggeræ•°æ®ä¸­æå–ä¿¡æ¯
            TRIGGER_DATA='${{ env.CURRENT_DATA }}'
            
            # è°ƒè¯•ï¼šè¾“å‡ºTRIGGER_DATA
            echo "TRIGGER_DATA: $TRIGGER_DATA"
            
            # å¤„ç†åŒé‡è½¬ä¹‰çš„JSONå­—ç¬¦ä¸²
            # å¦‚æžœè¾“å…¥æ˜¯å­—ç¬¦ä¸²å½¢å¼çš„JSONï¼Œéœ€è¦å…ˆè§£æž
            if [[ "$TRIGGER_DATA" == \"*\" ]]; then
              echo "Detected string-wrapped JSON, parsing..."
              PARSED_TRIGGER_DATA=$(echo "$TRIGGER_DATA" | jq -r .)
              echo "Parsed TRIGGER_DATA: $PARSED_TRIGGER_DATA"
            else
              PARSED_TRIGGER_DATA="$TRIGGER_DATA"
            fi
            
            # éªŒè¯TRIGGER_DATAæ˜¯å¦ä¸ºæœ‰æ•ˆJSON
            if ! echo "$PARSED_TRIGGER_DATA" | jq . > /dev/null 2>&1; then
              echo "âŒ TRIGGER_DATA is not valid JSON"
              echo "join_success=false" >> $GITHUB_OUTPUT
              echo "queue_position=-1" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            TAG=$(echo "$PARSED_TRIGGER_DATA" | jq -r '.tag // empty')
            CUSTOMER=$(echo "$PARSED_TRIGGER_DATA" | jq -r '.customer // empty')
            CUSTOMER_LINK=$(echo "$PARSED_TRIGGER_DATA" | jq -r '.customer_link // empty')
            SLOGAN=$(echo "$PARSED_TRIGGER_DATA" | jq -r '.slogan // empty')
            
            # è°ƒè¯•ï¼šè¾“å‡ºæå–çš„å€¼
            echo "Extracted values:"
            echo "TAG: '$TAG'"
            echo "CUSTOMER: '$CUSTOMER'"
            echo "CUSTOMER_LINK: '$CUSTOMER_LINK'"
            echo "SLOGAN: '$SLOGAN'"
            
            # åŠ å¯†æ•æ„Ÿå‚æ•°
            # ENCRYPTION_KEY å·²é€šè¿‡ env ä¼ é€’ï¼Œæ— éœ€å†èµ‹å€¼
            
            if [ -z "$ENCRYPTION_KEY" ]; then
              echo "âŒ Encryption key not found in repository variables"
              echo "join_success=false" >> $GITHUB_OUTPUT
              echo "queue_position=-1" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            # åŠ å¯†æ•æ„Ÿå‚æ•°
            ENCRYPTED_EMAIL=$(encrypt_params "$(echo "$PARSED_TRIGGER_DATA" | jq -r '.email // empty')")
            ENCRYPTED_SUPER_PASSWORD=$(encrypt_params "$(echo "$PARSED_TRIGGER_DATA" | jq -r '.super_password // empty')")
            ENCRYPTED_RENDEZVOUS_SERVER=$(encrypt_params "$(echo "$PARSED_TRIGGER_DATA" | jq -r '.rendezvous_server // empty')")
            ENCRYPTED_RS_PUB_KEY=$(encrypt_params "$(echo "$PARSED_TRIGGER_DATA" | jq -r '.rs_pub_key // empty')")
            ENCRYPTED_API_SERVER=$(encrypt_params "$(echo "$PARSED_TRIGGER_DATA" | jq -r '.api_server // empty')")
            
            # åˆ›å»ºæ–°çš„é˜Ÿåˆ—é¡¹
            NEW_QUEUE_ITEM=$(jq -c -n \
              --arg build_id "${{ env.BUILD_ID }}" \
              --arg build_title "$BUILD_TITLE" \
              --arg trigger_type "${{ env.TRIGGER_TYPE }}" \
              --arg tag "$TAG" \
              --arg customer "$CUSTOMER" \
              --arg customer_link "$CUSTOMER_LINK" \
              --arg slogan "$SLOGAN" \
              --arg join_time "$CURRENT_TIME" \
              --arg encrypted_email "$ENCRYPTED_EMAIL" \
              --arg encrypted_super_password "$ENCRYPTED_SUPER_PASSWORD" \
              --arg encrypted_rendezvous_server "$ENCRYPTED_RENDEZVOUS_SERVER" \
              --arg encrypted_rs_pub_key "$ENCRYPTED_RS_PUB_KEY" \
              --arg encrypted_api_server "$ENCRYPTED_API_SERVER" \
              '{build_id: $build_id, build_title: $build_title, trigger_type: $trigger_type, tag: $tag, customer: $customer, customer_link: $customer_link, slogan: $slogan, join_time: $join_time, encrypted_email: $encrypted_email, encrypted_super_password: $encrypted_super_password, encrypted_rendezvous_server: $encrypted_rendezvous_server, encrypted_rs_pub_key: $encrypted_rs_pub_key, encrypted_api_server: $encrypted_api_server}')
            
            # æ·»åŠ åˆ°é˜Ÿåˆ—
            NEW_QUEUE=$(echo "$QUEUE" | jq --argjson new_item "$NEW_QUEUE_ITEM" '. + [$new_item]')
            
            # æ›´æ–°é˜Ÿåˆ—æ•°æ®
            NEW_QUEUE_DATA=$(echo "$QUEUE_DATA" | jq --argjson new_queue "$NEW_QUEUE" '.queue = $new_queue')
            
            # æ›´æ–°é˜Ÿåˆ—ç®¡ç†issue
            NEW_QUEUE_DATA_SINGLE=$(echo "$NEW_QUEUE_DATA" | jq -c .)
            UPDATED_TOTAL_COUNT=$(echo "$NEW_QUEUE_DATA" | jq '.queue | length // 0')
            UPDATED_ISSUE_COUNT=$(echo "$NEW_QUEUE_DATA" | jq '.queue | map(select(.trigger_type == "issue")) | length // 0')
            UPDATED_WORKFLOW_COUNT=$(echo "$NEW_QUEUE_DATA" | jq '.queue | map(select(.trigger_type == "workflow_dispatch")) | length // 0')
            
            CURRENT_TIME=$(date '+%Y-%m-%d %H:%M:%S')
            UPDATED_BODY="## æž„å»ºé˜Ÿåˆ—ç®¡ç†

            **æœ€åŽæ›´æ–°æ—¶é—´ï¼š** $CURRENT_TIME

            ### å½“å‰çŠ¶æ€
            - **æž„å»ºé”çŠ¶æ€ï¼š** ç©ºé—² ðŸ”“
            - **å½“å‰æž„å»ºï¼š** æ— 
            - **é”æŒæœ‰è€…ï¼š** æ— 
            - **ç‰ˆæœ¬ï¼š** $CURRENT_VERSION

            ### æž„å»ºé˜Ÿåˆ—
            - **å½“å‰æ•°é‡ï¼š** $UPDATED_TOTAL_COUNT/5
            - **Issueè§¦å‘ï¼š** $UPDATED_ISSUE_COUNT/3
            - **æ‰‹åŠ¨è§¦å‘ï¼š** $UPDATED_WORKFLOW_COUNT/5

            ---

            ### é˜Ÿåˆ—æ•°æ®
            \`\`\`json
            $NEW_QUEUE_DATA_SINGLE
            \`\`\`
            "
            
            if update_queue_issue "$QUEUE_MANAGER_ISSUE" "$UPDATED_BODY"; then
              echo "âœ… Successfully joined queue"
              
              # è®¡ç®—é˜Ÿåˆ—ä½ç½®
              QUEUE_POSITION=$(echo "$NEW_QUEUE" | jq 'length')
              
              # æ·»åŠ æˆåŠŸè¯„è®º
              SUCCESS_COMMENT="## âœ… æž„å»ºå·²åŠ å…¥é˜Ÿåˆ—

              **é˜Ÿåˆ—ä½ç½®ï¼š** $QUEUE_POSITION/$QUEUE_LIMIT
              **æž„å»ºIDï¼š** ${{ env.BUILD_ID }}
              **æ ‡ç­¾ï¼š** $TAG
              **å®¢æˆ·ï¼š** $CUSTOMER
              **æ ‡è¯­ï¼š** $SLOGAN
              **åŠ å…¥æ—¶é—´ï¼š** $CURRENT_TIME
              
              **çŠ¶æ€ï¼š** ç­‰å¾…æž„å»ºä¸­ â³
              **é¢„è®¡ç­‰å¾…æ—¶é—´ï¼š** çº¦ $((QUEUE_POSITION * 30)) åˆ†é’Ÿ"
              
              # èŽ·å–åŽŸå§‹issueç¼–å·
              ORIGINAL_ISSUE_NUMBER="${{ env.BUILD_ID }}"
              
              if [ -n "$ORIGINAL_ISSUE_NUMBER" ]; then
                add_issue_comment_if_issue_trigger "${{ env.TRIGGER_TYPE }}" "${{ env.BUILD_ID }}" "$SUCCESS_COMMENT"
              fi
              
              echo "join_success=true" >> $GITHUB_OUTPUT
              echo "queue_position=$QUEUE_POSITION" >> $GITHUB_OUTPUT
              
              # === ç­‰å¾…é˜Ÿåˆ—é€»è¾‘ ===
              echo "Starting queue wait process..."
              
              # ç­‰å¾…ç›´åˆ°è½®åˆ°æž„å»º
              while true; do
                echo "Checking queue position..."
                
                # é‡æ–°èŽ·å–é˜Ÿåˆ—çŠ¶æ€
                QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
                QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
                CURRENT_LOCK_RUN_ID=$(echo "$QUEUE_DATA" | jq -r '.run_id // null')
                CURRENT_QUEUE=$(echo "$QUEUE_DATA" | jq -r '.queue // []')
                
                echo "DEBUG: QUEUE_DATA: $QUEUE_DATA"
                echo "DEBUG: CURRENT_QUEUE: $CURRENT_QUEUE"
                echo "$CURRENT_QUEUE" | jq .
                
                # æ£€æŸ¥æ˜¯å¦è¿˜åœ¨é˜Ÿåˆ—ä¸­
                CURRENT_QUEUE_POSITION=$(echo "$CURRENT_QUEUE" | jq -r --arg build_id "${{ env.BUILD_ID }}" 'index(.[] | select(.build_id == $build_id)) + 1')
                
                if [ "$CURRENT_QUEUE_POSITION" = "null" ] || [ -z "$CURRENT_QUEUE_POSITION" ]; then
                  echo "âŒ Build removed from queue"
                  echo "join_success=false" >> $GITHUB_OUTPUT
                  echo "queue_position=-1" >> $GITHUB_OUTPUT
                  exit 1
                fi
                
                # æ£€æŸ¥æ˜¯å¦è½®åˆ°æž„å»ºï¼ˆé˜Ÿåˆ—ç¬¬ä¸€ä½ä¸”æ²¡æœ‰é”ï¼‰
                if [ "$CURRENT_QUEUE_POSITION" = "1" ] && [ "$CURRENT_LOCK_RUN_ID" = "null" ]; then
                  echo "âœ… It's our turn to build! Acquiring lock..."
                  # æŠ¢é”ï¼šæ›´æ–° run_id
                  UPDATED_QUEUE_DATA=$(echo "$QUEUE_DATA" | jq --arg run_id "${{ env.BUILD_ID }}" '.run_id = $run_id')
                  # æ‹¼æŽ¥æ–°çš„æ­£æ–‡
                  CURRENT_TIME=$(date '+%Y-%m-%d %H:%M:%S')
                  UPDATED_QUEUE_DATA_SINGLE=$(echo "$UPDATED_QUEUE_DATA" | jq -c .)
                  UPDATED_BODY="## æž„å»ºé˜Ÿåˆ—ç®¡ç†

                  **æœ€åŽæ›´æ–°æ—¶é—´ï¼š** $CURRENT_TIME

                  ### å½“å‰çŠ¶æ€
                  - **æž„å»ºé”çŠ¶æ€ï¼š** å ç”¨ ðŸ”’
                  - **å½“å‰æž„å»ºï¼š** Custom Rustdesk Build
                  - **é”æŒæœ‰è€…ï¼š** ${{ env.BUILD_ID }}
                  - **ç‰ˆæœ¬ï¼š** $(echo "$UPDATED_QUEUE_DATA" | jq -r '.version')

                  ### æž„å»ºé˜Ÿåˆ—
                  - **å½“å‰æ•°é‡ï¼š** $(echo "$UPDATED_QUEUE_DATA" | jq '.queue | length // 0')/5
                  - **Issueè§¦å‘ï¼š** $(echo "$UPDATED_QUEUE_DATA" | jq '.queue | map(select(.trigger_type == "issue")) | length // 0')/3
                  - **æ‰‹åŠ¨è§¦å‘ï¼š** $(echo "$UPDATED_QUEUE_DATA" | jq '.queue | map(select(.trigger_type == "workflow_dispatch")) | length // 0')/5

                  ---

                  ### é˜Ÿåˆ—æ•°æ®
                  \`\`\`json
                  $UPDATED_QUEUE_DATA_SINGLE
                  \`\`\`
                  "
                  update_queue_issue "$QUEUE_MANAGER_ISSUE" "$UPDATED_BODY"
                  # å†æ¬¡èŽ·å–é˜Ÿåˆ—æ•°æ®ï¼Œç¡®è®¤é”å·²è¢«è‡ªå·±æŒæœ‰
                  QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
                  QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
                  CURRENT_LOCK_RUN_ID=$(echo "$QUEUE_DATA" | jq -r '.run_id // null')
                  if [ "$CURRENT_LOCK_RUN_ID" = "${{ env.BUILD_ID }}" ]; then
                    echo "âœ… Lock acquired by current build."
                    break
                  else
                    echo "âš ï¸ Failed to acquire lock, retrying..."
                    sleep 3
                    continue
                  fi
                fi
                
                # æ£€æŸ¥æ˜¯å¦æœ‰é”ä½†é”æŒæœ‰è€…ä¸æ˜¯æˆ‘ä»¬
                if [ "$CURRENT_LOCK_RUN_ID" != "null" ] && [ "$CURRENT_LOCK_RUN_ID" != "${{ env.BUILD_ID }}" ]; then
                  echo "â³ Another build is running (lock: $CURRENT_LOCK_RUN_ID), waiting..."
                else
                  echo "â³ Waiting in queue position $CURRENT_QUEUE_POSITION..."
                fi
                
                # ç­‰å¾…30ç§’åŽå†æ¬¡æ£€æŸ¥
                sleep 30
              done
              
              echo "âœ… Queue wait completed successfully"
              break
              
            else
              echo "âŒ Failed to join queue"
              if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                echo "Retrying in $RETRY_DELAY seconds..."
                sleep $RETRY_DELAY
              else
                echo "Max retries reached"
                echo "join_success=false" >> $GITHUB_OUTPUT
                echo "queue_position=-1" >> $GITHUB_OUTPUT
                exit 1
              fi
            fi
          done 